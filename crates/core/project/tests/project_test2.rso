use moon_config::{
    GlobalProjectConfig, PlatformType, ProjectConfig, ProjectDependsOn, ProjectLanguage,
    ProjectMetadataConfig, ProjectType, TargetID, TaskCommandArgs, TaskConfig, TaskMergeStrategy,
    TaskOptionsConfig,
};
use moon_project::{Project, ProjectError};
use moon_task::{EnvVars, FileGroup, Target, Task};
use moon_test_utils::{get_fixtures_path, get_fixtures_root};
use moon_utils::string_vec;
use rustc_hash::{FxHashMap, FxHashSet};
use std::collections::BTreeMap;
use std::path::Path;

pub fn create_file_groups_config() -> FxHashMap<String, Vec<String>> {
    let mut map = FxHashMap::default();

    map.insert(
        String::from("static"),
        string_vec![
            "file.ts",
            "dir",
            "dir/other.tsx",
            "dir/subdir",
            "dir/subdir/another.ts",
        ],
    );

    map.insert(String::from("dirs_glob"), string_vec!["**/*"]);

    map.insert(String::from("files_glob"), string_vec!["**/*.{ts,tsx}"]);

    map.insert(String::from("globs"), string_vec!["**/*.{ts,tsx}", "*.js"]);

    map.insert(String::from("no_globs"), string_vec!["config.js"]);

    map
}

fn mock_file_groups() -> FxHashMap<String, FileGroup> {
    FxHashMap::from_iter([(
        String::from("sources"),
        FileGroup::new("sources", string_vec!["src/**/*"]),
    )])
}

fn mock_global_project_config() -> GlobalProjectConfig {
    GlobalProjectConfig {
        extends: None,
        file_groups: FxHashMap::from_iter([(String::from("sources"), string_vec!["src/**/*"])]),
        tasks: BTreeMap::new(),
        schema: String::new(),
    }
}

fn create_expanded_project(
    id: &str,
    source: &str,
    workspace_root: &Path,
    config: &GlobalProjectConfig,
) -> Project {
    let mut project = Project::new(id, source, workspace_root, config).unwrap();
    project.expand_tasks(workspace_root, &[], &[]).unwrap();
    project
}

#[test]
fn overrides_global_file_groups() {
    let workspace_root = get_fixtures_root();
    let project = Project::new(
        "basic",
        "projects/basic",
        &workspace_root,
        &GlobalProjectConfig {
            file_groups: FxHashMap::from_iter([(String::from("tests"), string_vec!["tests/**/*"])]),
            ..GlobalProjectConfig::default()
        },
    )
    .unwrap();

    assert_eq!(
        project,
        Project {
            id: String::from("basic"),
            config: ProjectConfig {
                depends_on: vec![ProjectDependsOn::String("noConfig".to_owned())],
                file_groups: FxHashMap::from_iter([(
                    String::from("tests"),
                    string_vec!["**/*_test.rs"]
                )]),
                language: ProjectLanguage::JavaScript,
                ..ProjectConfig::default()
            },
            log_target: String::from("moon:project:basic"),
            root: workspace_root.join("projects/basic"),
            file_groups: FxHashMap::from_iter([(
                String::from("tests"),
                FileGroup::new("tests", string_vec!["**/*_test.rs"],)
            )]),
            source: String::from("projects/basic"),
            ..Project::default()
        }
    );
}

mod tasks {
    use super::*;
    use moon_task::test::{
        create_expanded_task as create_expanded_task_internal, create_file_groups_config,
    };
    use moon_test_utils::pretty_assertions::assert_eq;
    use moon_utils::glob;

    fn mock_task_config(command: &str) -> TaskConfig {
        TaskConfig {
            command: Some(TaskCommandArgs::String(command.to_owned())),
            ..TaskConfig::default()
        }
    }

    fn mock_merged_task_options_config(strategy: TaskMergeStrategy) -> TaskOptionsConfig {
        TaskOptionsConfig {
            merge_args: Some(strategy.clone()),
            merge_deps: Some(strategy.clone()),
            merge_env: Some(strategy.clone()),
            merge_inputs: Some(strategy.clone()),
            merge_outputs: Some(strategy),
            retry_count: Some(1),
            run_deps_in_parallel: Some(true),
            run_in_ci: Some(true),
            ..TaskOptionsConfig::default()
        }
    }

    fn mock_local_task_options_config(strategy: TaskMergeStrategy) -> TaskOptionsConfig {
        TaskOptionsConfig {
            merge_args: Some(strategy.clone()),
            merge_deps: Some(strategy.clone()),
            merge_env: Some(strategy.clone()),
            merge_inputs: Some(strategy.clone()),
            merge_outputs: Some(strategy),
            ..TaskOptionsConfig::default()
        }
    }

    fn stub_global_task_options_config() -> TaskOptionsConfig {
        TaskOptionsConfig {
            cache: Some(true),
            retry_count: Some(1),
            run_deps_in_parallel: Some(true),
            run_in_ci: Some(true),
            ..TaskOptionsConfig::default()
        }
    }

    fn stub_global_env_vars() -> EnvVars {
        FxHashMap::from_iter([
            ("GLOBAL".to_owned(), "1".to_owned()),
            ("KEY".to_owned(), "a".to_owned()),
        ])
    }

    fn create_expanded_task(
        target: TargetID,
        config: TaskConfig,
        workspace_root: &Path,
        project_source: &str,
    ) -> Result<Task, ProjectError> {
        let project_root = workspace_root.join(project_source);
        let mut task =
            create_expanded_task_internal(workspace_root, &project_root, Some(config)).unwrap();

        let mut parts = target.split(':');
        parts.next();

        task.log_target = format!("moon:project:{}", target);
        task.id = parts.next().unwrap().to_string();
        task.target = Target::parse(&target).unwrap();

        Ok(task)
    }

    mod expands_deps {
        use super::*;
        use moon_test_utils::pretty_assertions::assert_eq;

        #[test]
        fn resolves_self_scope() {
            let project = create_expanded_project(
                "id",
                "self",
                &get_fixtures_path("task-deps"),
                &mock_global_project_config(),
            );

            assert_eq!(
                project.tasks.get("lint").unwrap().deps,
                Task::create_dep_targets(&string_vec!["id:clean", "id:build"]).unwrap()
            );
        }

        #[test]
        fn resolves_self_scope_without_prefix() {
            let project = create_expanded_project(
                "id",
                "self-no-prefix",
                &get_fixtures_path("task-deps"),
                &mock_global_project_config(),
            );

            assert_eq!(
                project.tasks.get("lint").unwrap().deps,
                Task::create_dep_targets(&string_vec!["id:clean", "id:build"]).unwrap()
            );
        }

        #[test]
        fn resolves_self_scope_without_dupes() {
            let project = create_expanded_project(
                "id",
                "self-dupes",
                &get_fixtures_path("task-deps"),
                &mock_global_project_config(),
            );

            assert_eq!(
                project.tasks.get("lint").unwrap().deps,
                Task::create_dep_targets(&string_vec!["id:build"]).unwrap()
            );
        }

        #[test]
        fn resolves_deps_scope() {
            let project = create_expanded_project(
                "id",
                "deps",
                &get_fixtures_path("task-deps"),
                &mock_global_project_config(),
            );

            assert_eq!(
                project.tasks.get("build").unwrap().deps,
                Task::create_dep_targets(&string_vec!["bar:build", "baz:build", "foo:build"])
                    .unwrap()
            );
        }

        #[test]
        fn resolves_deps_scope_without_dupes() {
            let project = create_expanded_project(
                "id",
                "deps-dupes",
                &get_fixtures_path("task-deps"),
                &mock_global_project_config(),
            );

            assert_eq!(
                project.tasks.get("build").unwrap().deps,
                Task::create_dep_targets(&string_vec!["foo:build", "bar:build", "baz:build"])
                    .unwrap()
            );
        }

        #[test]
        #[should_panic(expected = "Target(NoProjectAllInTaskDeps(\":build\"))")]
        fn errors_for_all_scope() {
            create_expanded_project(
                "id",
                "all",
                &get_fixtures_path("task-deps"),
                &mock_global_project_config(),
            );
        }
    }

    mod tokens {
        use super::*;
        use moon_config::DependencyConfig;
        use moon_project::ProjectDependency;
        use moon_test_utils::pretty_assertions::assert_eq;
        use std::path::PathBuf;

        #[test]
        fn expands_args() {
            let project = create_expanded_project(
                "id",
                "base/files-and-dirs",
                &get_fixtures_root(),
                &GlobalProjectConfig {
                    file_groups: create_file_groups_config(),
                    tasks: BTreeMap::from([(
                        String::from("test"),
                        TaskConfig {
                            args: Some(TaskCommandArgs::Sequence(string_vec![
                                "--dirs",
                                "@dirs(static)",
                                "--files",
                                "@files(static)",
                                "--globs",
                                "@globs(globs)",
                                "--root",
                                "@root(static)",
                            ])),
                            command: Some(TaskCommandArgs::String("test".to_owned())),
                            ..TaskConfig::default()
                        },
                    )]),
                    ..GlobalProjectConfig::default()
                },
            );

            assert_eq!(
                *project.tasks.get("test").unwrap().args,
                if cfg!(windows) {
                    vec![
                        "--dirs",
                        ".\\dir",
                        ".\\dir\\subdir",
                        "--files",
                        ".\\file.ts",
                        ".\\dir\\other.tsx",
                        ".\\dir\\subdir\\another.ts",
                        "--globs",
                        "./**/*.{ts,tsx}",
                        "./*.js",
                        "--root",
                        ".\\dir",
                    ]
                } else {
                    vec![
                        "--dirs",
                        "./dir",
                        "./dir/subdir",
                        "--files",
                        "./file.ts",
                        "./dir/other.tsx",
                        "./dir/subdir/another.ts",
                        "--globs",
                        "./**/*.{ts,tsx}",
                        "./*.js",
                        "--root",
                        "./dir",
                    ]
                },
            )
        }

        #[test]
        fn expands_args_from_workspace() {
            let workspace_root = get_fixtures_root();
            let project_root = workspace_root.join("base").join("files-and-dirs");
            let project = create_expanded_project(
                "id",
                "base/files-and-dirs",
                &workspace_root,
                &GlobalProjectConfig {
                    file_groups: create_file_groups_config(),
                    tasks: BTreeMap::from([(
                        String::from("test"),
                        TaskConfig {
                            args: Some(TaskCommandArgs::Sequence(string_vec![
                                "--dirs",
                                "@dirs(static)",
                                "--files",
                                "@files(static)",
                                "--globs",
                                "@globs(globs)",
                                "--root",
                                "@root(static)",
                            ])),
                            command: Some(TaskCommandArgs::String("test".to_owned())),
                            options: TaskOptionsConfig {
                                run_from_workspace_root: Some(true),
                                ..TaskOptionsConfig::default()
                            },
                            ..TaskConfig::default()
                        },
                    )]),
                    ..GlobalProjectConfig::default()
                },
            );

            assert_eq!(
                *project.tasks.get("test").unwrap().args,
                vec![
                    "--dirs",
                    project_root.join("dir").to_str().unwrap(),
                    project_root.join("dir").join("subdir").to_str().unwrap(),
                    "--files",
                    project_root.join("file.ts").to_str().unwrap(),
                    project_root.join("dir").join("other.tsx").to_str().unwrap(),
                    project_root
                        .join("dir")
                        .join("subdir")
                        .join("another.ts")
                        .to_str()
                        .unwrap(),
                    "--globs",
                    glob::remove_drive_prefix(
                        glob::normalize(project_root.join("**/*.{ts,tsx}")).unwrap()
                    )
                    .as_str(),
                    glob::remove_drive_prefix(glob::normalize(project_root.join("*.js")).unwrap())
                        .as_str(),
                    "--root",
                    project_root.join("dir").to_str().unwrap(),
                ],
            )
        }

        #[test]
        fn expands_args_with_vars() {
            let workspace_root = get_fixtures_root();
            let project_root = workspace_root.join("base").join("files-and-dirs");
            let project = create_expanded_project(
                "id",
                "base/files-and-dirs",
                &workspace_root,
                &GlobalProjectConfig {
                    file_groups: create_file_groups_config(),
                    tasks: BTreeMap::from([(
                        String::from("test"),
                        TaskConfig {
                            args: Some(TaskCommandArgs::Sequence(string_vec![
                                "some/$unknown/var", // Unknown
                                "--pid",
                                "$project/foo", // At start
                                "--proot",
                                "$projectRoot", // Alone
                                "--psource",
                                "foo/$projectSource", // At end
                                "--target",
                                "foo/$target/bar", // In middle
                                "--tid=$task",     // As an arg
                                "--wsroot",
                                "$workspaceRoot" // Alone
                            ])),
                            command: Some(TaskCommandArgs::String("test".to_owned())),
                            ..TaskConfig::default()
                        },
                    )]),
                    ..GlobalProjectConfig::default()
                },
            );

            assert_eq!(
                *project.tasks.get("test").unwrap().args,
                vec![
                    "some/$unknown/var",
                    "--pid",
                    "id/foo",
                    "--proot",
                    project_root.to_str().unwrap(),
                    "--psource",
                    // This is wonky but also still valid
                    if cfg!(windows) {
                        "foo/base\\files-and-dirs"
                    } else {
                        "foo/base/files-and-dirs"
                    },
                    "--target",
                    "foo/id:test/bar",
                    "--tid=test",
                    "--wsroot",
                    workspace_root.to_str().unwrap(),
                ],
            )
        }

        #[test]
        fn expands_inputs() {
            let workspace_root = get_fixtures_path("base");
            let project_root = workspace_root.join("files-and-dirs");
            let project = create_expanded_project(
                "id",
                "files-and-dirs",
                &workspace_root,
                &GlobalProjectConfig {
                    file_groups: create_file_groups_config(),
                    tasks: BTreeMap::from([(
                        String::from("test"),
                        TaskConfig {
                            command: Some(TaskCommandArgs::String("test".to_owned())),
                            inputs: Some(string_vec![
                                "file.ts",
                                "@dirs(static)",
                                "@files(static)",
                                "@globs(globs)",
                                "@root(static)",
                                "/package.json",
                            ]),
                            ..TaskConfig::default()
                        },
                    )]),
                    ..GlobalProjectConfig::default()
                },
            );

            let task = project.tasks.get("test").unwrap();

            assert_eq!(
                task.input_globs,
                FxHashSet::from_iter([
                    glob::normalize(project_root.join("**/*.{ts,tsx}")).unwrap(),
                    glob::normalize(project_root.join("*.js")).unwrap()
                ]),
            );

            let a: FxHashSet<PathBuf> =
                FxHashSet::from_iter(task.input_paths.iter().map(PathBuf::from));
            let b: FxHashSet<PathBuf> = FxHashSet::from_iter(
                vec![
                    project_root.join("file.ts"),
                    project_root.join("dir"),
                    project_root.join("dir/subdir"),
                    project_root.join("file.ts"),
                    project_root.join("dir/other.tsx"),
                    project_root.join("dir/subdir/another.ts"),
                    workspace_root.join("package.json"),
                ]
                .iter()
                .map(PathBuf::from),
            );

            assert_eq!(a, b);
        }

        #[test]
        fn expands_implicit_deps() {
            let workspace_root = get_fixtures_path("base");
            let mut project = Project::new(
                "id",
                "files-and-dirs",
                &workspace_root,
                &GlobalProjectConfig {
                    file_groups: create_file_groups_config(),
                    tasks: BTreeMap::from([(
                        String::from("test"),
                        TaskConfig {
                            command: Some(TaskCommandArgs::String("test".to_owned())),
                            deps: Some(string_vec!["~:test"]),
                            platform: PlatformType::Node,
                            ..TaskConfig::default()
                        },
                    )]),
                    ..GlobalProjectConfig::default()
                },
            )
            .unwrap();

            project.dependencies.insert(
                "example".into(),
                ProjectDependency::from_config(&DependencyConfig::new("example")),
            );

            project
                .expand_tasks(
                    &workspace_root,
                    &string_vec!["^:build", "project:task"],
                    &[],
                )
                .unwrap();

            let task = project.tasks.get("test").unwrap();

            assert_eq!(
                task.deps,
                Task::create_dep_targets(&string_vec!["id:test", "example:build", "project:task"])
                    .unwrap()
            );
        }

        #[test]
        fn expands_implicit_inputs() {
            let workspace_root = get_fixtures_path("base");
            let project_root = workspace_root.join("files-and-dirs");
            let mut project = Project::new(
                "id",
                "files-and-dirs",
                &workspace_root,
                &GlobalProjectConfig {
                    file_groups: create_file_groups_config(),
                    tasks: BTreeMap::from([(
                        String::from("test"),
                        TaskConfig {
                            command: Some(TaskCommandArgs::String("test".to_owned())),
                            inputs: Some(string_vec!["local.ts",]),
                            platform: PlatformType::Node,
                            ..TaskConfig::default()
                        },
                    )]),
                    ..GlobalProjectConfig::default()
                },
            )
            .unwrap();

            project
                .expand_tasks(
                    &workspace_root,
                    &[],
                    &[
                        "/.moon/$taskPlatform-$projectType.yml".to_owned(),
                        "*.yml".to_owned(),
                    ],
                )
                .unwrap();

            let task = project.tasks.get("test").unwrap();

            assert_eq!(
                task.input_globs,
                FxHashSet::from_iter([glob::normalize(project_root.join("*.yml")).unwrap()])
            );

            let a: FxHashSet<PathBuf> =
                FxHashSet::from_iter(task.input_paths.iter().map(PathBuf::from));
            let b: FxHashSet<PathBuf> = FxHashSet::from_iter(
                vec![
                    project_root.join("local.ts"),
                    workspace_root.join(".moon/node-unknown.yml"),
                ]
                .iter()
                .map(PathBuf::from),
            );

            assert_eq!(a, b);
        }
    }
}

mod workspace {
    use super::*;
    use moon_task::test::create_expanded_task;

    mod inherited_tasks {
        use super::*;

        fn mock_global_project_config() -> GlobalProjectConfig {
            GlobalProjectConfig {
                file_groups: FxHashMap::default(),
                tasks: BTreeMap::from([
                    (
                        String::from("a"),
                        TaskConfig {
                            command: Some(TaskCommandArgs::String("a".to_owned())),
                            ..TaskConfig::default()
                        },
                    ),
                    (
                        String::from("b"),
                        TaskConfig {
                            command: Some(TaskCommandArgs::String("b".to_owned())),
                            ..TaskConfig::default()
                        },
                    ),
                    (
                        String::from("c"),
                        TaskConfig {
                            command: Some(TaskCommandArgs::String("c".to_owned())),
                            ..TaskConfig::default()
                        },
                    ),
                ]),
                ..GlobalProjectConfig::default()
            }
        }

        fn get_project_task_ids(project: Project) -> Vec<String> {
            let mut ids = project.tasks.into_keys().collect::<Vec<String>>();
            ids.sort();
            ids
        }

        #[test]
        fn include() {
            let project = create_expanded_project(
                "id",
                "include",
                &get_fixtures_path("task-inheritance"),
                &mock_global_project_config(),
            );

            assert_eq!(get_project_task_ids(project), string_vec!["a", "c"])
        }

        #[test]
        fn include_none() {
            let project = create_expanded_project(
                "id",
                "include-none",
                &get_fixtures_path("task-inheritance"),
                &mock_global_project_config(),
            );

            assert_eq!(get_project_task_ids(project), string_vec![])
        }

        #[test]
        fn exclude() {
            let project = create_expanded_project(
                "id",
                "exclude",
                &get_fixtures_path("task-inheritance"),
                &mock_global_project_config(),
            );

            assert_eq!(get_project_task_ids(project), string_vec!["b"])
        }

        #[test]
        fn exclude_all() {
            let project = create_expanded_project(
                "id",
                "exclude-all",
                &get_fixtures_path("task-inheritance"),
                &mock_global_project_config(),
            );

            assert_eq!(get_project_task_ids(project), string_vec![])
        }

        #[test]
        fn exclude_none() {
            let project = create_expanded_project(
                "id",
                "exclude-none",
                &get_fixtures_path("task-inheritance"),
                &mock_global_project_config(),
            );

            assert_eq!(get_project_task_ids(project), string_vec!["a", "b", "c"])
        }

        #[test]
        fn rename() {
            let project = create_expanded_project(
                "id",
                "rename",
                &get_fixtures_path("task-inheritance"),
                &mock_global_project_config(),
            );

            assert_eq!(
                get_project_task_ids(project),
                string_vec!["bar", "baz", "foo"]
            )
        }

        #[test]
        fn rename_merge() {
            let workspace_root = get_fixtures_path("task-inheritance");
            let project = create_expanded_project(
                "id",
                "rename-merge",
                &workspace_root,
                &mock_global_project_config(),
            );

            let mut task =
                create_expanded_task(&workspace_root, &workspace_root.join("rename-merge"), None)
                    .unwrap();
            task.id = "foo".to_owned();
            task.target = Target::new("id", "foo").unwrap();
            task.command = "a".to_owned();
            task.args.push("renamed-and-merge-foo".to_owned());
            task.log_target = "moon:project:id:foo".to_owned();

            assert_eq!(*project.get_task("foo").unwrap(), task);

            assert_eq!(get_project_task_ids(project), string_vec!["b", "c", "foo"]);
        }

        #[test]
        fn include_exclude() {
            let project = create_expanded_project(
                "id",
                "include-exclude",
                &get_fixtures_path("task-inheritance"),
                &mock_global_project_config(),
            );

            assert_eq!(get_project_task_ids(project), string_vec!["a"])
        }

        #[test]
        fn include_exclude_rename() {
            let project = create_expanded_project(
                "id",
                "include-exclude-rename",
                &get_fixtures_path("task-inheritance"),
                &mock_global_project_config(),
            );

            assert_eq!(get_project_task_ids(project), string_vec!["only"])
        }
    }
}
