---
title: Plugins
toc_max_heading_level: 4
---

proto supports a pluggable architecture as a means for consumers to integrate and manage custom
tools (languages, CLIs, etc) within proto's toolchain. It's not possible for proto to support
_everything_ in core directly, so plugins are a way for the community to extend the toolchain to
their needs.

## Enabling plugins

Plugins can be enabled by configuring them in
[`.prototools` or `~/.proto/config.toml`](./config#plugins) files.

```toml title=".prototools"
[plugins]
my-tool = "source:https://raw.githubusercontent.com/my/tool/master/proto-plugin.wasm"
```

## Creating a plugin

To ease the plugin development process, proto supports 2 types of plugins, a TOML based plugin, and
a WASM based plugin.

### TOML plugin

The TOML plugin is by design, very simple. It's a TOML file that describes a schema for the tool,
how it should be installed, and how it should be invoked. Since this is a static configuration file,
it does not support any logic or complex behavior, and is merely for simple and common use cases,
like CLIs.

Let's start by creating a new schema plugin, and defining the `name` and `type` fields. The type can
either be `language`, `dependency-manager`, or `cli`. For this example, we'll create a plugin for
our fake product called Protostar, a CLI tool.

```toml title="protostar.toml"
name = "Protostar"
type = "cli"
```

#### Platform variations

Native tools are often platform specific, and proto supports this by allowing you to define
variations based on operating system using the `[platform]` section. For non-native tools, this
section can typically be skipped.

This section requires a mapping of Rust
[`OS` strings](https://doc.rust-lang.org/std/env/consts/constant.OS.html) to platform settings. The
following settings are available:

- `archive-prefix` - If the tool is distributed as an archive (zip, tar, etc), this is the name of
  the direct folder within the archive that contains the tool, and will be removed when unpacking
  the archive. If there is no prefix folder within the archive, this setting can be omitted.
- `bin-path` - The path to the executable binary within the archive (without the prefix). If the
  tool is distributed as a single binary, this setting can be typically omitted.
- `checksum-file` - Name of the checksum file to verify the downloaded file with. If the tool does
  not support checksum verification, this setting can be omitted.
- `download-file` (required) - Name of the file to download.
  [Learn more about downloading](#downloading-and-installing).

```toml title="protostar.toml"
# ...

[platform.linux]
archive-prefix = "protostar-linux"
bin-path = "bins/protostar"
checksum-file = "protostar-{arch}-unknown-linux-{libc}.sha256"
download-file = "protostar-{arch}-unknown-linux-{libc}.tar.gz"

[platform.macos]
archive-prefix = "protostar-macos"
bin-path = "bins/protostar"
checksum-file = "protostar-{arch}-apple-darwin.sha256"
download-file = "protostar-{arch}-apple-darwin.tar.xz"

[platform.windows]
archive-prefix = "protostar-windows"
bin-path = "bins/protostar.exe"
checksum-file = "protostar-{arch}-pc-windows-msvc.sha256"
download-file = "protostar-{arch}-pc-windows-msvc.zip"
```

You may have noticed tokens above, like `{arch}`. These are special tokens that are replaced with a
dynamic value at runtime, based on the current host machine executing the code. The following tokens
are available:

- `{version}` - The currently resolved version, as a fully-qualifed semantic version:
  `major.minor.patch`.
- `{arch}` - The architecture of the host machine, like `x86_64`. These values map to Rust's
  [`ARCH` constant](https://doc.rust-lang.org/std/env/consts/constant.ARCH.html), but can be
  customized with [`install.arch`](#downloading-and-installing).
- `{libc}` - For Linux machines, this is the current libc implementation, either `gnu` or `musl`.

#### Downloading and installing

A schema plugin _only_ supports downloading pre-built tools, typically as an archive, and does _not_
support building from source. The `[install]` section can be used to configure how the tool should
be downloaded and installed into the toolchain. The following settings are available:

- `arch` - A mapping of Rust
  [`ARCH` strings](https://doc.rust-lang.org/std/env/consts/constant.ARCH.html) to custom values for
  the `{arch}` token. This is useful if the tool has different terminology.
- `checksum-url` - A secure URL to download the checksum file for verification. If the tool does not
  support checksum verification, this setting can be omitted.
- `download-url` (required) - A secure URL to download the tool/archive.
- `unpack` - Whether the downloaded file should be unpacked or not. For tools that download the
  binary directly, this should be disabled.

The URL settings support `{checksum_file}` and `{download_file}` tokens, which will be replaced with
the values from the `[platform]` section.

```toml title="protostar.toml"
# ...

[install]
checksum-url = "https://github.com/moonrepo/protostar/releases/download/v{version}/{checksum_file}"
download-url = "https://github.com/moonrepo/protostar/releases/download/v{version}/{download_file}"

[install.arch]
aarch64 = "arm64"
x86_64 = "x64"
```

The `[install]` sections also supports the following settings that dictate the installation of
global binaries for the tool. If the tool does not support globals (is not a programming language),
these settings can be omitted.

- `globals-dir` - A list of directories to locate and install the global binaries into. This setting
  supports interpolating environment variables via the syntax `$ENV_VAR`.
- `global-args` - A list of CLI arguments to pass to the tool to install a global binary. The name
  of the binary can be inserted using the `{dependency}` token.

```toml title="protostar.toml"
# ...

[install]
globals-dir = ["$PROTOSTAR_HOME/bin", "$HOME/.protostar/bin"]
global-args = ["install", "--force", "{dependency}"]
```

#### Resolving versions

Now that the tool can be downloaded and installed, we must configure how to resolve available
versions. Resolving is configured through the `[resolve]` section, which supports 2 patterns to
resolve with: Git tags, or a JSON manifest.

###### Git tags

To resolve a list of available versions using Git tags, the following settings are available:

- `git-url` - The remote URL to fetch tags from.
- `git-tag-pattern` - A regular expression to filter and match with. Defaults to
  `^v?((\d+)\.(\d+)\.(\d+))`. The capture group `1` will be extracted as the version.

```toml title="protostar.toml"
# ...

[resolve]
git-url = "https://github.com/moonrepo/protostar"
git-tag-pattern = "^@protostar/cli@((\\d+)\.(\\d+)\.(\\d+))"
```

###### JSON manifest

To resolve a list of available versions using a JSON manifest, the following settings are available:

- `manifest-url` - A URL that returns a JSON response of all versions. This response _must be_ an
  array of strings, or an array of objects.
- `manifest-version-key` - If the response is an array of objects, this is the key to extract the
  version from. If the response is an array of strings, this setting can be omitted. Defaults to
  `version`.

```toml title="protostar.toml"
# ...

[resolve]
manifest-url = "https://someregistry.com/protostar/versions.json"
manifest-version-key = "latest_version"
```

#### Detecting versions

And lastly, we can configure how to [detect a version](./detection) contextually at runtime, using
the `[detect]` setting. At this time, we only support 1 setting:

- `version-files` - A list of version files to extract from. The contents of these files can _only_
  be the version string itself.

```toml title="protostar.toml"
# ...

[detect]
version-files = [".protostar-version", ".protostarrc"]
```

### WASM plugin (experimental)

Plugins can also be written in [WebAssembly (WASM)](https://webassembly.org/), a portable binary
format. This means that plugins can be written in any language that compiles to WASM, like Rust, C,
C++, Go, TypeScript, and more. Because WASM based plugins are powered by a programming language,
they implicitly support complex business logic and behavior, have access to a sandboxed file system,
can execute child processes, and much more.

However, since WASM executes in its own runtime, it _does not_ have access to the current host
operating system, architecture, environment variables, and more. To bridge this gap, we provide this
information as an `env` field for every function input (more below).

:::danger

Since our WASM plugin implementation is still experimental, expect breaking changes to occur in
non-major releases.

:::

#### Creating the project

:::info

Although plugins can be written in any language that compiles to WASM, we've only tested Rust. The
rest of this article assume you're using Rust and Cargo! Refer to [Extism](https://extism.org/)'s
documentation for other examples.

:::

To start, create a new crate with Cargo:

```shell
cargo new plugin --lib
cd plugin
```

And set the lib type to `cdylib`.

```toml title="Cargo.toml"
[lib]
crate-type = ['cdylib']
```

Our Rust plugins are powered by [Extism](https://extism.org/), so lets add their PDK and ours as a
dependency.

```shell
cargo add extism-pdk proto_pdk
```

In all Rust files, we can import both PDKs with the following:

```rust title="src/lib.rs"
use extism_pdk::*;
use proto_pdk::*;
```

We can then build the WASM binary. The file will be available at
`target/wasm32-wasi/debug/<name>.wasm`.

```
cargo build --target wasm32-wasi
```

#### Registering metadata

The first step in a plugin's life-cycle is to register metadata about the plugin with the
`register_tool` function. This function is called immediately after a plugin is loaded at runtime,
and must return a human-readable name and plugin type.

```rust
#[plugin_fn]
pub fn register_tool(_: ()) -> FnResult<Json<ToolMetadataOutput>> {
    Ok(Json(ToolMetadataOutput {
        name: "Node.js".into(),
        type_of: PluginType::Language,
        ..ToolMetadataOutput::default()
    }))
}
```

This function also receives the plugin ID as input, allowing for conditional logic based on the ID.
The ID is the [key the plugin was configured with](#enabling-plugins), and what is passed to `proto`
commands (e.g. `proto install <id>`).

```rust
#[plugin_fn]
pub fn register_tool(Json(input): Json<ToolMetadataInput>) -> FnResult<Json<ToolMetadataOutput>> {
  input.id
  // ...
}
```

#### Downloading and installing

Our plugin layer _only_ supports downloading pre-built tools, typically as an archive, and does
_not_ support building from source. The `download_prebuilt` function _must_ be defined, whichs
configures how the tool should be downloaded and installed.

The following fields are available:

- `archive_prefix` - If the tool is distributed as an archive (zip, tar, etc), this is the name of
  the direct folder within the archive that contains the tool, and will be removed when unpacking
  the archive. If there is no prefix folder within the archive, this setting can be omitted.
- `download_url` (required) - A secure URL to download the tool/archive.
- `download_name` - File name of the archive to download. If not provided, will attempt to extract
  it from the URL.
- `checksum_url` - A secure URL to download the checksum file for verification. If the tool does not
  support checksum verification, this setting can be omitted.

```rust
#[plugin_fn]
pub fn download_prebuilt(Json(input): Json<DownloadPrebuiltInput>) -> FnResult<Json<DownloadPrebuiltOutput>> {
    let version = input.env.version;
    let arch = input.env.arch;
    let os = input.env.os;

    let prefix = match os {
        HostOS::Linux => format!("node-v{version}-linux-{arch}"),
        HostOS::MacOS => format!("node-v{version}-darwin-{arch}"),
        HostOS::Windows => format!("node-v{version}-win-{arch}"),
        other => {
            return Err(PluginError::UnsupportedPlatform("Node.js".into(), other.into()))?;
        }
    };

    let filename = if os == HostOS::Windows {
        format!("{prefix}.zip")
    } else {
        format!("{prefix}.tar.xz")
    };

    Ok(Json(DownloadPrebuiltOutput {
        archive_prefix: Some(prefix),
        download_url: format!("https://nodejs.org/dist/v{version}/{filename}"),
        download_name: Some(filename),
        checksum_url: Some(format!("https://nodejs.org/dist/v{version}/SHASUMS256.txt")),
        ..DownloadPrebuiltOutput::default()
    }))
}
```

#### Unpacking an archive

Our plugin layer will do its best to detect file extensions, unpack the downloaded file (if an
archive), and install the tool to the correct directory. However, we're unable to account for _all_
edge cases, so for situations where the install params above are not sufficient, you may define an
`unpack_archive` function.

This function receives an input with the following fields:

- `input_file` - Virtual path to the downloaded file. Maps to `~/.proto/temp/<id>/<file>`.
- `output_dir` - Virtual directory to unpack the archive into, or copy the binary to. Maps to
  `~/.proto/tools/<id>/<version>`.

```rust
#[plugin_fn]
pub fn unpack_archive(Json(input): Json<UnpackArchiveInput>) -> FnResult<()> {
    untar(input.input_file, input.output_dir)?;
    Ok(())
}
```

#### Locating binaries

Even though a tool has been installed, we must inform proto of where to find the binary to execute.
This can be achieved with the optional `locate_bins` function. If this function is not defined,
proto will assume the binary is named `<id>` (`<id>.exe` on Windows), relative from the installation
directory.

```rust
#[plugin_fn]
pub fn locate_bins(Json(input): Json<LocateBinsInput>) -> FnResult<Json<LocateBinsOutput>> {
    Ok(Json(LocateBinsOutput {
        bin_path: Some(if input.env.os == HostOS::Windows {
            "node.exe".into()
        } else {
            "bin/node".into()
        }),
        ..LocateBinsOutput::default()
    }))
}
```

Furthermore, the `locate_bins` function can define a list of lookups for the globals installation
directory. proto will loop through each lookup, and return the first directory that exists on the
current file system. proto will also expand environment variables in the format of `$VAR_NAME`. If a
variable is not defined, or has an empty value, the lookup will be skipped. To demonstrate this,
we'll use [Deno](https://deno.land/manual@v1.35.0/tools/script_installer).

```rust
#[plugin_fn]
pub fn locate_bins(Json(_): Json<LocateBinsInput>) -> FnResult<Json<LocateBinsOutput>> {
    Ok(Json(LocateBinsOutput {
        globals_lookup_dirs: vec!["$DENO_INSTALL_ROOT/bin".into(), "$HOME/.deno/bin".into()],
        ..LocateBinsOutput::default()
    }))
}
```

#### Loading and resolving versions

Now that the tool can be downloaded and installed, we must configure how to resolve available
versions to actually be installed. To provide a list of versions and language specific aliases, the
`load_versions` function must be defined.

```rust
#[plugin_fn]
pub fn load_versions(Json(_): Json<LoadVersionsInput>) -> FnResult<Json<LoadVersionsOutput>> {
    let mut output = LoadVersionsOutput::default();
    let response: Vec<NodeDistVersion> = fetch_url("https://nodejs.org/dist/index.json")?;

    for (index, item) in response.iter().enumerate() {
        let version = Version::parse(&item.version[1..])?; // Starts with v

        if index == 0 {
            output.latest = Some(version.clone());
        }

        output.versions.push(version);
    }

    Ok(Json(output))
}
```

Furthermore, we support an optional function named `resolve_version`, that can be defined to
intercept the version resolution process. This function receives an input with an initial candidate,
either an alias or version, and can replace it with a new candidate. The candidate must be a valid
alias or version as defined in `load_versions`.

```rust
#[plugin_fn]
pub fn resolve_version(
    Json(input): Json<ResolveVersionInput>,
) -> FnResult<Json<ResolveVersionOutput>> {
    let mut output = ResolveVersionOutput::default();

    if input.initial == "node" {
        output.candidate = Some("latest".into());

    } else if input.initial == "lts-*" || input.initial == "lts/*" {
        output.candidate = Some("stable".into());

    } else if input.initial.starts_with("lts-") || input.initial.starts_with("lts/") {
        output.candidate = Some(input.initial[4..].to_owned());
    }

    Ok(Json(output))
}
```

#### Detecting versions

And lastly, we can configure how to [detect a version](./detection) contextually at runtime, using
the `detect_version_files` function and optional `parse_version_file` function. The
`detect_version_files` function can return a list of files to locate within a directory.

```rust
#[plugin_fn]
pub fn detect_version_files(_: ()) -> FnResult<Json<DetectVersionOutput>> {
    Ok(Json(DetectVersionOutput {
        files: vec![
            ".nvmrc".into(),
            ".node-version".into(),
            "package.json".into(),
        ],
    }))
}
```

By default our plugin layer will assume the version file's contents contain the literal version, and
nothing else, like "1.2.3". If any of the files in the `detect_version_files` list require custom
parsing (for example, `package.json` above), you can define the `parse_version_file` function.

This function receives the file name and contents as input, and must return the parsed version (if
applicable).

```rust
#[plugin_fn]
pub fn parse_version_file(Json(input): Json<ParseVersionInput>) -> FnResult<Json<ParseVersionOutput>> {
    let mut version = None;

    if input.file == "package.json" {
        let json: PackageJson = serde_json::from_str(&input.content)?;

        if let Some(engines) = json.engines {
            if let Some(constraint) = engines.get("node") {
                version = Some(constraint.to_owned());
            }
        }
    } else {
        version = Some(input.content.trim().to_owned());
    }

    Ok(Json(ParseVersionOutput { version }))
}
```

#### Creating shims

Tools within proto wouldn't function without shims, and as such, plugins can register their own
shims to be created. By default, proto _will always_ create a global shim of the plugin at
`~/.proto/bin/<id>`, but you can also register additional shims with the `create_shims` function.

##### Global shims

Global shims are optional scripts that are available on `PATH` as they are generated in the
`~/.proto/bin` directory, and can be defined with the `global_shims` parameter. This param is a hash
map, where the key is the shim file name, and the value is a relative path (from the tool's
directory) to a binary to execute.

```rust
#[plugin_fn]
pub fn create_shims(Json(input): Json<CreateShimsInput>) -> FnResult<Json<CreateShimsOutput>> {
    let mut global_shims = HashMap::new();

    global_shims.insert("npx".into(), if input.env.os == HostOS::Windows {
        "npx.cmd".into()
    } else {
        "bin/npx".into()
    });

    Ok(Json(CreateShims {
        global_shims,
        ..CreateShims::default()
    }))
}
```
