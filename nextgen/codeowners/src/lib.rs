use chrono::Local;
use moon_config::{OwnersConfig, OwnersPaths, VcsProvider};
use starbase_utils::fs::{self, FsError};
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};

pub struct CodeownersGenerator {
    file: File,
    file_path: PathBuf,
    provider: VcsProvider,
}

impl CodeownersGenerator {
    pub fn new(workspace_root: &Path, provider: VcsProvider) -> Result<Self, FsError> {
        let file_path = workspace_root.join(match provider {
            VcsProvider::GitHub => ".github/CODEOWNERS",
            VcsProvider::GitLab => ".gitlab/CODEOWNERS",
            _ => "CODEOWNERS",
        });

        let mut generator = CodeownersGenerator {
            file: fs::create_file(&file_path)?,
            file_path,
            provider,
        };

        generator.write("# Automatically generated by moon. DO NOT MODIFY!")?;
        generator.write(format!("# Last generated: {}", Local::now()))?;
        generator.write("")?;

        Ok(generator)
    }

    pub fn add_project_entry(
        &mut self,
        name: &str,
        source: &str,
        config: &OwnersConfig,
    ) -> Result<(), FsError> {
        self.write("")?;

        // Render the header
        self.write(format!("# {} ({})", name, source))?;

        match &self.provider {
            VcsProvider::Bitbucket => {
                if config.required_approvals > 1 {
                    if let Some(default_owner) = &config.default_owner {
                        self.write(format!(
                            "Check({} >= {})",
                            default_owner, config.required_approvals
                        ))?;
                    }
                }
            }

            VcsProvider::GitLab => {
                let mut header = format!("[{name}]");

                if config.optional {
                    header = format!("^{header}")
                }

                if config.required_approvals > 1 {
                    header = format!("{header}[{}]", config.required_approvals);
                }

                if matches!(config.paths, OwnersPaths::List(_)) {
                    header = format!("{header} {}", config.default_owner.as_ref().unwrap());
                }

                self.write(header)?;
            }
            _ => {}
        };

        // Render the owner entries
        self.render_entries(source, config)?;

        Ok(())
    }

    fn render_entries(&mut self, source: &str, config: &OwnersConfig) -> Result<(), FsError> {
        todo!()
    }

    fn write<T: AsRef<str>>(&mut self, message: T) -> Result<(), FsError> {
        writeln!(self.file, "{}", message.as_ref()).map_err(|error| FsError::Create {
            path: self.file_path.to_path_buf(),
            error,
        })?;

        Ok(())
    }

    // pub fn build(self) -> Codeowners {
    //     Codeowners { file: self.file }
    // }
}
